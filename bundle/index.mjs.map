{
  "version": 3,
  "sources": ["../src/core/registry.ts", "../src/validation/index.ts", "../src/factory/index.ts"],
  "sourcesContent": ["/**\n * \uC2A4\uD0A4\uB9C8 \uBE4C\uB354 & \uD0C0\uC785 \uB808\uC9C0\uC2A4\uD2B8\uB9AC\n */\n\nimport { \n    Schema, \n    PrimitiveSchema, \n    ArraySchema, \n    ObjectSchema, \n    CustomSchema,\n    TypeDefinition \n} from './types';\n\n\n/**\n * A utility object for creating different kinds of schema definitions.\n * Each method in this builder corresponds to a specific schema type.\n */\nexport const SchemaBuilder = {\n    /**\n     * Creates a schema definition for a primitive 'string' type.\n     * @returns {PrimitiveSchema} A schema object representing a string.\n     * @example\n     * ```typescript\n     * const nameSchema = SchemaBuilder.string();\n     * // Result: { kind: 'primitive', type: 'string' }\n     * ```\n     */\n    string(): PrimitiveSchema {\n        return { kind: 'primitive', type: 'string' };\n    },\n    \n    /**\n     * Creates a schema definition for a primitive 'number' type.\n     * @returns {PrimitiveSchema} A schema object representing a number.\n     * @example\n     * ```typescript\n     * const ageSchema = SchemaBuilder.number();\n     * // Result: { kind: 'primitive', type: 'number' }\n     * ```\n     */\n    number(): PrimitiveSchema {\n        return { kind: 'primitive', type: 'number' };\n    },\n    \n    /**\n     * Creates a schema definition for a primitive 'boolean' type.\n     * @returns {PrimitiveSchema} A schema object representing a boolean.\n     * @example\n     * ```typescript\n     * const isActiveSchema = SchemaBuilder.boolean();\n     * // Result: { kind: 'primitive', type: 'boolean' }\n     * ```\n     */\n    boolean(): PrimitiveSchema {\n        return { kind: 'primitive', type: 'boolean' };\n    },\n    \n    /**\n     * Creates a schema definition for an 'array' type.\n     * If `items` contains a single schema, it defines a homogeneous array where all elements must conform to that schema.\n     * If `items` contains multiple schemas, it defines a tuple where elements at each position must conform to the corresponding schema.\n     * @param {Schema[]} items - An array of schema definitions.\n     *                         - For a homogeneous array (e.g., array of strings), pass a single-element array: `[SchemaBuilder.string()]`.\n     *                         - For a tuple (e.g., `[string, number]`), pass an array with schemas for each element: `[SchemaBuilder.string(), SchemaBuilder.number()]`.\n     * @param {object} [options] - Optional configuration for the array.\n     * @param {number} [options.minItems] - The minimum number of items the array must contain.\n     * @param {number} [options.maxItems] - The maximum number of items the array can contain.\n     * @returns {ArraySchema} A schema object representing an array.\n     * @example\n     * ```typescript\n     * // Homogeneous array of strings\n     * const tagsSchema = SchemaBuilder.array([SchemaBuilder.string()], { minItems: 1 });\n     * // Result: { kind: 'array', items: [{ kind: 'primitive', type: 'string' }], minItems: 1 }\n     *\n     * // Tuple of a string and a number\n     * const pairSchema = SchemaBuilder.array([\n     *   SchemaBuilder.string(),\n     *   SchemaBuilder.number()\n     * ]);\n     * // Result: { kind: 'array', items: [{ kind: 'primitive', type: 'string' }, { kind: 'primitive', type: 'number' }] }\n     *\n     * // Array of numbers with min and max items (homogeneous)\n     * const scoresSchema = SchemaBuilder.array(\n     *   [SchemaBuilder.number()], // Note: items is an array\n     *   { minItems: 1, maxItems: 5 }\n     * );\n     * // Result: { kind: 'array', items: [{ kind: 'primitive', type: 'number' }], minItems: 1, maxItems: 5 }\n     * ```\n     */\n    array(items: Schema[], options?: { minItems?: number; maxItems?: number }): ArraySchema {\n        return {\n            kind: 'array',\n            items,\n            ...options\n        };\n    },\n    \n    /**\n     * Creates a schema definition for an 'object' type.\n     * @param {Record<string, Schema>} properties - An object where keys are property names and values are their schema definitions.\n     * @param {object} [options] - Optional configuration for the object.\n     * @param {string[]} [options.required] - An array of property names that are required for this object.\n     * @param {boolean} [options.additionalProperties=false] - Whether to allow properties not defined in the schema. Defaults to false.\n     * @returns {ObjectSchema} A schema object representing an object.\n     * @example\n     * ```typescript\n     * // Simple object\n     * const pointSchema = SchemaBuilder.object({\n     *   x: SchemaBuilder.number(),\n     *   y: SchemaBuilder.number()\n     * });\n     * // Result: { kind: 'object', properties: { x: { kind: 'primitive', type: 'number' }, y: { kind: 'primitive', type: 'number' } }, additionalProperties: false }\n     *\n     * // Object with required properties and allowing additional properties\n     * const userProfileSchema = SchemaBuilder.object(\n     *   {\n     *     id: SchemaBuilder.string(),\n     *     username: SchemaBuilder.string(),\n     *     email: SchemaBuilder.custom('email') // Assumes 'email' custom type is defined\n     *   },\n     *   { required: ['id', 'username'], additionalProperties: true }\n     * );\n     * // Result: {\n     * //   kind: 'object',\n     * //   properties: { id: ..., username: ..., email: ... },\n     * //   required: ['id', 'username'],\n     * //   additionalProperties: true\n     * // }\n     * ```\n     */\n    object(\n        properties: Record<string, Schema>, \n        options?: { required?: string[]; additionalProperties?: boolean }\n    ): ObjectSchema {\n        return {\n            kind: 'object',\n            properties,\n            required: options?.required,\n            additionalProperties: options?.additionalProperties ?? false\n        };\n    },\n    \n    /**\n     * Creates a schema definition for a 'custom' type.\n     * Custom types allow for user-defined validation logic and can optionally wrap an existing schema.\n     * @param {string} typeName - The unique name identifying this custom type. This name is used for registration and lookup.\n     * @param {object} [options] - Optional configuration for the custom type.\n     * @param {(value: any) => boolean} [options.validator] - A function to validate the value of this custom type. Should return true if valid, false otherwise.\n     * @param {Schema} [options.innerSchema] - An underlying schema that this custom type is based on or extends.\n     * @returns {CustomSchema} A schema object representing a custom type.\n     * @example\n     * ```typescript\n     * // Custom type with a validator\n     * const emailSchema = SchemaBuilder.custom('email', {\n     *   validator: (value) => typeof value === 'string' && /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)\n     * });\n     * // Result: { kind: 'custom', typeName: 'email', validator: [Function] }\n     *\n     * // Custom type based on an inner schema (e.g., a positive number)\n     * const positiveNumberSchema = SchemaBuilder.custom('positiveNumber', {\n     *   innerSchema: SchemaBuilder.number(),\n     *   validator: (value) => typeof value === 'number' && value > 0\n     * });\n     * // Result: { kind: 'custom', typeName: 'positiveNumber', innerSchema: { kind: 'primitive', type: 'number' }, validator: [Function] }\n     *\n     * // Custom type that just references another registered type (validation handled by the registered type)\n     * const userIdSchema = SchemaBuilder.custom('UUID');\n     * // Result: { kind: 'custom', typeName: 'UUID' }\n     * // (Assumes a 'UUID' type is registered elsewhere with its own schema and/or validator)\n     *\n     * // Custom type with only an inner schema (useful for aliasing or adding semantic meaning)\n     * const productCodeSchema = SchemaBuilder.custom('ProductCode', { innerSchema: SchemaBuilder.string() });\n     * // Result: { kind: 'custom', typeName: 'ProductCode', innerSchema: { kind: 'primitive', type: 'string' } }\n     * ```\n     */\n    custom(\n        typeName: string, \n        options?: { validator?: (value: any) => boolean; innerSchema?: Schema }\n    ): CustomSchema {\n        return {\n            kind: 'custom',\n            typeName,\n            validator: options?.validator,\n            innerSchema: options?.innerSchema\n        };\n    }\n};\n\n\nexport const STRING_TYPE: TypeDefinition<'string'> = {\n    name: 'string',\n    schema: SchemaBuilder.string(),\n    description: 'Text string value'\n} as const;\n\nexport const NUMBER_TYPE: TypeDefinition<'number'> = {\n    name: 'number',\n    schema: SchemaBuilder.number(),\n    description: 'Numeric value'\n} as const;\n\nexport const BOOLEAN_TYPE: TypeDefinition<'boolean'> = {\n    name: 'boolean',\n    schema: SchemaBuilder.boolean(),\n    description: 'True or false value'\n} as const;\n\n\n/**\n * Manages the registration and retrieval of type definitions.\n * This class acts as a central store for all defined types within the system,\n * ensuring that each type name is unique and providing easy access to type information.\n */\nexport class TypeRegistry {\n    /** @internal */\n    private static types = new Map<string, TypeDefinition>();\n    \n    /**\n     * Initializes the TypeRegistry with predefined basic types (string, number, boolean).\n     * @internal\n     */\n    static {\n        this.registerType(STRING_TYPE);\n        this.registerType(NUMBER_TYPE);\n        this.registerType(BOOLEAN_TYPE);\n    }\n    \n    /**\n     * Registers a new type definition.\n     * Throws an error if a type with the same name is already registered.\n     * @template T - The literal string type of the type name.\n     * @param {TypeDefinition<T>} typeDefinition - The type definition object to register.\n     * @throws {Error} If the type name is already registered.\n     */\n    static registerType<T extends string>(typeDefinition: TypeDefinition<T>): void {\n        if (this.types.has(typeDefinition.name)) {\n            throw new Error(`Type '${typeDefinition.name}' is already registered`);\n        }\n        this.types.set(typeDefinition.name, typeDefinition);\n    }\n    \n    /**\n     * Retrieves a type definition by its name.\n     * @param {string} typeName - The name of the type to retrieve.\n     * @returns {TypeDefinition | undefined} The type definition if found, otherwise undefined.\n     */\n    static getType(typeName: string): TypeDefinition | undefined {\n        return this.types.get(typeName);\n    }\n    \n    /**\n     * Checks if a type with the given name is registered.\n     * @param {string} typeName - The name of the type to check.\n     * @returns {boolean} True if the type is registered, false otherwise.\n     */\n    static hasType(typeName: string): boolean {\n        return this.types.has(typeName);\n    }\n    \n    /**\n     * Retrieves all registered type definitions.\n     * @returns {ReadonlyMap<string, TypeDefinition>} A read-only map of all type definitions.\n     */\n    static getAllTypes(): ReadonlyMap<string, TypeDefinition> {\n        return this.types;\n    }\n    \n    /**\n     * Retrieves the names of all registered types.\n     * @returns {string[]} An array of registered type names.\n     */\n    static getTypeNames(): string[] {\n        return Array.from(this.types.keys());\n    }\n}\n\n/**\n * Creates a new type definition and registers it with the TypeRegistry.\n *\n * @template T - \uD0C0\uC785 \uC774\uB984\uC758 \uBB38\uC790\uC5F4 \uB9AC\uD130\uB7F4 \uD0C0\uC785\n * @param {T} name - The unique name of the type to register.\n * @param {Schema} schema - The schema defining the structure of the type.\n * @param {string} [description] - An optional description for the type.\n * @returns {TypeDefinition<T>} The created type definition object.\n * @throws {Error} If a type with the same name is already registered.\n *\n * @example\n * ```typescript\n * // Simple custom type definition\n * const EmailType = defineType(\n *   'email',\n *   SchemaBuilder.custom('email', {\n *     validator: (value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value)\n *   }),\n *   'Represents an email address format'\n * );\n *\n * // Object type definition\n * const UserType = defineType(\n *   'user',\n *   SchemaBuilder.object({\n *     id: SchemaBuilder.number(),\n *     name: SchemaBuilder.string(),\n *     email: SchemaBuilder.custom('email')\n *   }, { required: ['id', 'name'] }),\n *   'Represents a user entity'\n * );\n * ```\n */\nexport function defineType<T extends string>(\n    name: T, \n    schema: Schema, \n    description?: string\n): TypeDefinition<T> {\n    const typeDefinition: TypeDefinition<T> = {\n        name,\n        schema,\n        description\n    };\n    \n    TypeRegistry.registerType(typeDefinition);\n    return typeDefinition;\n}\n", "/**\n * \uC2A4\uD0A4\uB9C8 \uAC80\uC99D & \uD0C0\uC785 \uD638\uD658\uC131 \uAC80\uC0AC\n */\n\nimport { \n    Schema, \n    PrimitiveSchema, \n    ArraySchema, \n    ObjectSchema, \n    CustomSchema,\n    ValidationResult,\n    CompatibilityResult,\n    ValueNode\n} from '../core/types';\nimport { TypeRegistry } from '../core/registry';\n\n/**\n * Provides static methods for validating values against schema definitions.\n */\nexport class SchemaValidator {\n    /**\n     * Validates a given value against a specified schema.\n     *\n     * @param {unknown} value - The value to validate.\n     * @param {Schema} schema - The schema to validate against.\n     * @returns {ValidationResult} An object indicating whether the validation was successful and a list of errors if not.\n     * @example\n     * ```typescript\n     * const stringSchema = SchemaBuilder.string();\n     * const result = SchemaValidator.validateValue(\"hello\", stringSchema);\n     * // result = { isValid: true, errors: [] }\n     * ```\n     */\n    static validateValue(value: unknown, schema: Schema): ValidationResult {\n        const errors: string[] = [];\n        \n        switch (schema.kind) {\n            case 'primitive':\n                this.validatePrimitive(value, schema as PrimitiveSchema, errors);\n                break;\n            case 'array':\n                this.validateArray(value, schema as ArraySchema, errors);\n                break;\n            case 'object':\n                this.validateObject(value, schema as ObjectSchema, errors);\n                break;\n            case 'custom':\n                this.validateCustom(value, schema as CustomSchema, errors);\n                break;\n            default:\n                const _exhaustiveCheck = schema;\n                throw new Error(`Unknown schema kind: ${(_exhaustiveCheck as any).kind}`);\n        }\n        \n        return { isValid: errors.length === 0, errors };\n    }\n    \n    /**\n     * Validates a value against a primitive schema.\n     * @internal\n     * @param {unknown} value - The value to validate.\n     * @param {PrimitiveSchema} schema - The primitive schema.\n     * @param {string[]} errors - An array to collect validation errors.\n     */\n    private static validatePrimitive(value: unknown, schema: PrimitiveSchema, errors: string[]): void {\n        const expectedType = schema.type;\n        const actualType = typeof value;\n        \n        if (expectedType === 'number' && actualType === 'number' && isNaN(value as number)) {\n            errors.push('Number value cannot be NaN');\n            return;\n        }\n        \n        if (actualType !== expectedType) {\n            errors.push(`Expected ${expectedType}, got ${actualType}`);\n        }\n    }\n    \n    /**\n     * Validates a value against an array schema.\n     * Handles both homogeneous arrays and tuples.\n     * @internal\n     * @param {unknown} value - The value to validate.\n     * @param {ArraySchema} schema - The array schema.\n     * @param {string[]} errors - An array to collect validation errors.\n     */\n    private static validateArray(value: unknown, schema: ArraySchema, errors: string[]): void {\n        if (!Array.isArray(value)) {\n            errors.push('Expected array');\n            return;\n        }\n        \n        // Overall array length constraints\n        if (schema.minItems !== undefined && value.length < schema.minItems) {\n            errors.push(`Array must have at least ${schema.minItems} items, got ${value.length}`);\n        }\n        if (schema.maxItems !== undefined && value.length > schema.maxItems) {\n            errors.push(`Array must have at most ${schema.maxItems} items, got ${value.length}`);\n        }\n\n        // Item validation based on schema.items structure\n        if (schema.items && schema.items.length > 0) {\n            if (schema.items.length === 1) {\n                // Homogeneous array: all items conform to schema.items[0]\n                const itemSchema = schema.items[0];\n                value.forEach((item, index) => {\n                    const itemValidation = this.validateValue(item, itemSchema);\n                    if (!itemValidation.isValid) {\n                        const itemErrors = itemValidation.errors.map(error => `Item[${index}]: ${error}`);\n                        errors.push(...itemErrors);\n                    }\n                });\n            } else {\n                // Tuple: value[i] conforms to schema.items[i]\n                // For tuples, the length of the data array should match the length of the schema.items array.\n                if (value.length !== schema.items.length) {\n                    errors.push(`Expected tuple of ${schema.items.length} elements, but got ${value.length} elements`);\n                }\n                // Validate elements up to the defined length of the tuple schema.\n                // If value.length is shorter, previous error handles it.\n                // If value.length is longer, previous error handles it.\n                // We iterate through schema.items to ensure each defined tuple element is checked.\n                schema.items.forEach((itemSchema, index) => {\n                    if (index < value.length) { // Check if value has an element at this index\n                        const itemValidation = this.validateValue(value[index], itemSchema);\n                        if (!itemValidation.isValid) {\n                            const itemErrors = itemValidation.errors.map(error => `Item at index ${index}: ${error}`);\n                            errors.push(...itemErrors);\n                        }\n                    } // If index >= value.length, the length mismatch error already covers missing elements.\n                });\n            }\n        } else if (schema.items && schema.items.length === 0 && value.length > 0) {\n            // Schema defines an empty tuple (e.g. `[]`), but data array is not empty.\n            errors.push(\"Array schema defines an empty tuple, but received a non-empty array.\");\n        }\n    }\n    \n    /**\n     * Validates a value against an object schema.\n     * @internal\n     * @param {unknown} value - The value to validate.\n     * @param {ObjectSchema} schema - The object schema.\n     * @param {string[]} errors - An array to collect validation errors.\n     */\n    private static validateObject(value: unknown, schema: ObjectSchema, errors: string[]): void {\n        if (typeof value !== 'object' || value === null || Array.isArray(value)) {\n            errors.push('Expected object');\n            return;\n        }\n        \n        const obj = value as Record<string, unknown>;\n        \n        if (schema.required) {\n            for (const requiredKey of schema.required) {\n                if (!(requiredKey in obj)) {\n                    errors.push(`Missing required property: '${requiredKey}'`);\n                }\n            }\n        }\n        \n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            if (key in obj) {\n                const propValidation = this.validateValue(obj[key], propSchema);\n                if (!propValidation.isValid) {\n                    const propErrors = propValidation.errors.map(error => `Property '${key}': ${error}`);\n                    errors.push(...propErrors);\n                }\n            }\n        }\n        \n        if (!schema.additionalProperties) {\n            const allowedKeys = new Set(Object.keys(schema.properties));\n            for (const key of Object.keys(obj)) {\n                if (!allowedKeys.has(key)) {\n                    errors.push(`Unexpected property: '${key}'`);\n                }\n            }\n        }\n    }\n    \n    /**\n     * Validates a value against a custom schema.\n     * @internal\n     * @param {unknown} value - The value to validate.\n     * @param {CustomSchema} schema - The custom schema.\n     * @param {string[]} errors - An array to collect validation errors.\n     */\n    private static validateCustom(value: unknown, schema: CustomSchema, errors: string[]): void {\n        if (schema.validator && !schema.validator(value)) {\n            errors.push(`Custom validation failed for type: ${schema.typeName}`);\n        }\n        \n        if (schema.innerSchema) {\n            const innerValidation = this.validateValue(value, schema.innerSchema);\n            if (!innerValidation.isValid) {\n                errors.push(...innerValidation.errors);\n            }\n        }\n    }\n}\n\n/**\n * Provides static methods for checking type compatibility based on their schemas.\n */\nexport class TypeCompatibility {\n    /**\n     * Checks if a source type is compatible with a target type by their names.\n     * Compatibility is determined by their underlying schemas.\n     * @param {string} sourceTypeName - The name of the source type.\n     * @param {string} targetTypeName - The name of the target type.\n     * @returns {boolean} True if the types are compatible, false otherwise.\n     * @example\n     * ```typescript\n     * TypeCompatibility.areCompatible('string', 'string'); // true\n     * ```\n     */\n    static areCompatible(sourceTypeName: string, targetTypeName: string): boolean {\n        if (sourceTypeName === targetTypeName) {\n            return true;\n        }\n        \n        const sourceType = TypeRegistry.getType(sourceTypeName);\n        const targetType = TypeRegistry.getType(targetTypeName);\n        \n        if (!sourceType || !targetType) {\n            return false;\n        }\n        \n        return this.areSchemasCompatible(sourceType.schema, targetType.schema);\n    }\n    \n    /**\n     * Checks compatibility between a source type and a target type, providing a reason if not compatible.\n     * @param {string} sourceTypeName - The name of the source type.\n     * @param {string} targetTypeName - The name of the target type.\n     * @returns {CompatibilityResult} An object indicating compatibility and a reason if not compatible.\n     * @example\n     * ```typescript\n     * const result = TypeCompatibility.checkCompatibility('number', 'string');\n     * // result = {\n     * //   isCompatible: false,\n     * //   reason: \"Type mismatch: number is not compatible with string\"\n     * // }\n     * ```\n     */\n    static checkCompatibility(sourceTypeName: string, targetTypeName: string): CompatibilityResult {\n        if (sourceTypeName === targetTypeName) {\n            return { isCompatible: true };\n        }\n        \n        const sourceType = TypeRegistry.getType(sourceTypeName);\n        const targetType = TypeRegistry.getType(targetTypeName);\n        \n        if (!sourceType) {\n            return { \n                isCompatible: false, \n                reason: `Unknown source type: ${sourceTypeName}` \n            };\n        }\n        \n        if (!targetType) {\n            return { \n                isCompatible: false, \n                reason: `Unknown target type: ${targetTypeName}` \n            };\n        }\n        \n        if (!this.areSchemasCompatible(sourceType.schema, targetType.schema)) {\n            return { \n                isCompatible: false, \n                reason: `Type mismatch: ${sourceTypeName} is not compatible with ${targetTypeName}` \n            };\n        }\n        \n        return { isCompatible: true };\n    }\n    \n    /**\n     * Checks if a given ValueNode is compatible with a target type name.\n     * @param {ValueNode} node - The ValueNode to check.\n     * @param {string} targetTypeName - The name of the target type.\n     * @returns {CompatibilityResult} An object indicating compatibility and a reason if not compatible.\n     * @example\n     * ```typescript\n     * const stringNode = ValueNodeFactory.createStringNode(\"test\");\n     * const result = TypeCompatibility.isNodeCompatible(stringNode, 'string');\n     * // result = { isCompatible: true }\n     * ```\n     */\n    static isNodeCompatible(node: ValueNode, targetTypeName: string): CompatibilityResult {\n        return this.checkCompatibility(node.type, targetTypeName);\n    }\n    \n    /**\n     * @internal\n     */\n    private static areSchemasCompatible(sourceSchema: Schema, targetSchema: Schema): boolean {\n        if (sourceSchema.kind !== targetSchema.kind) {\n            return false;\n        }\n        \n        switch (sourceSchema.kind) {\n            case 'primitive':\n                if (targetSchema.kind !== 'primitive') return false;\n                return (sourceSchema as PrimitiveSchema).type === (targetSchema as PrimitiveSchema).type;\n                \n            case 'array':\n                if (targetSchema.kind !== 'array') return false;\n                const sourceArraySchema = sourceSchema as ArraySchema;\n                const targetArraySchema = targetSchema as ArraySchema;\n\n                if (!sourceArraySchema.items || !targetArraySchema.items) {\n                     // Undefined items arrays are not compatible unless both are undefined (or specific rule)\n                    return !sourceArraySchema.items && !targetArraySchema.items;\n                }\n                if (sourceArraySchema.items.length === 0 || targetArraySchema.items.length === 0) {\n                    return sourceArraySchema.items.length === targetArraySchema.items.length; // Compatible if both are empty\n                }\n\n                // Both are homogeneous array definitions\n                if (sourceArraySchema.items.length === 1 && targetArraySchema.items.length === 1) {\n                    return this.areSchemasCompatible(sourceArraySchema.items[0], targetArraySchema.items[0]);\n                } \n                // Both are tuple definitions\n                else if (sourceArraySchema.items.length === targetArraySchema.items.length) { // Lengths must match for tuples\n                    for (let i = 0; i < sourceArraySchema.items.length; i++) {\n                        if (!this.areSchemasCompatible(sourceArraySchema.items[i], targetArraySchema.items[i])) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n                return false; // Mixed types (tuple vs homogeneous) or different length tuples\n                \n            case 'object':\n                if (targetSchema.kind !== 'object') return false;\n                return this.areObjectSchemasCompatible(\n                    sourceSchema as ObjectSchema, \n                    targetSchema as ObjectSchema\n                );\n                \n            case 'custom':\n                if (targetSchema.kind !== 'custom') return false;\n                return (sourceSchema as CustomSchema).typeName === (targetSchema as CustomSchema).typeName;\n                \n            default:\n                return false;\n        }\n    }\n    \n    /**\n     * @internal\n     */\n    private static areObjectSchemasCompatible(source: ObjectSchema, target: ObjectSchema): boolean {\n        const targetRequiredKeys = new Set(target.required || []);\n        const sourceKeys = new Set(Object.keys(source.properties));\n        \n        for (const requiredKey of targetRequiredKeys) {\n            if (!sourceKeys.has(requiredKey)) {\n                return false;\n            }\n        }\n        \n        for (const [key, targetPropSchema] of Object.entries(target.properties)) {\n            if (key in source.properties) {\n                if (!this.areSchemasCompatible(source.properties[key], targetPropSchema)) {\n                    return false;\n                }\n            }\n        }\n        \n        return true;\n    }\n}\n", "/**\n * \uAC12 \uB178\uB4DC \uD329\uD1A0\uB9AC & \uC720\uD2F8\uB9AC\uD2F0\n */\n\nimport { ValueNode } from '../core/types';\nimport { TypeRegistry } from '../core/registry';\nimport { SchemaValidator } from '../validation/index';\n\n// \uAC12 \uB178\uB4DC \uD329\uD1A0\uB9AC\nexport class ValueNodeFactory {\n    static createTypedNode<T extends string, U>(typeName: T, value: U): ValueNode<T, U> {\n        const typeDefinition = TypeRegistry.getType(typeName);\n        if (!typeDefinition) {\n            throw new Error(`Unknown type: ${typeName}. Available types: ${TypeRegistry.getTypeNames().join(', ')}`);\n        }\n        \n        const validation = SchemaValidator.validateValue(value, typeDefinition.schema);\n        if (!validation.isValid) {\n            throw new Error(`Schema validation failed for type '${typeName}': ${validation.errors.join('; ')}`);\n        }\n        \n        return { type: typeName, value };\n    }\n    \n    static createStringNode(value: string): ValueNode<'string', string> {\n        return this.createTypedNode('string', value);\n    }\n    \n    static createNumberNode(value: number): ValueNode<'number', number> {\n        return this.createTypedNode('number', value);\n    }\n    \n    static createBooleanNode(value: boolean): ValueNode<'boolean', boolean> {\n        return this.createTypedNode('boolean', value);\n    }\n    \n    static tryCreateNode<T extends string, U>(\n        typeName: T, \n        value: U\n    ): { success: true; node: ValueNode<T, U> } | { success: false; error: string } {\n        try {\n            const node = this.createTypedNode(typeName, value);\n            return { success: true, node };\n        } catch (error) {\n            return { \n                success: false, \n                error: error instanceof Error ? error.message : String(error) \n            };\n        }\n    }\n}\n\n// \uC720\uD2F8\uB9AC\uD2F0 \uD568\uC218\uB4E4\nexport function validateTypeValue(typeName: string, value: unknown): string[] {\n    const typeDefinition = TypeRegistry.getType(typeName);\n    if (!typeDefinition) {\n        return [`Unknown type: ${typeName}`];\n    }\n    \n    const validation = SchemaValidator.validateValue(value, typeDefinition.schema);\n    return validation.errors;\n}\n\nexport function inspectType(typeName: string): void {\n    const typeDefinition = TypeRegistry.getType(typeName);\n    if (!typeDefinition) {\n        console.log(`Type '${typeName}' not found`);\n        return;\n    }\n    \n    console.log(`=== Type: ${typeName} ===`);\n    console.log(`Description: ${typeDefinition.description || 'No description'}`);\n    console.log(`Schema:`, JSON.stringify(typeDefinition.schema, null, 2));\n}\n\nexport function listAllTypes(): void {\n    const allTypes = TypeRegistry.getAllTypes();\n    \n    console.log('=== Registered Types ===');\n    for (const [name, definition] of allTypes) {\n        console.log(`${name}: ${definition.description || 'No description'}`);\n    }\n}\n"],
  "mappings": ";AAkBO,IAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUzB,SAA0B;AACtB,WAAO,EAAE,MAAM,aAAa,MAAM,SAAS;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,SAA0B;AACtB,WAAO,EAAE,MAAM,aAAa,MAAM,SAAS;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,UAA2B;AACvB,WAAO,EAAE,MAAM,aAAa,MAAM,UAAU;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkCA,MAAM,OAAiB,SAAiE;AACpF,WAAO;AAAA,MACH,MAAM;AAAA,MACN;AAAA,MACA,GAAG;AAAA,IACP;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmCA,OACI,YACA,SACY;AACZ,WAAO;AAAA,MACH,MAAM;AAAA,MACN;AAAA,MACA,UAAU,SAAS;AAAA,MACnB,sBAAsB,SAAS,wBAAwB;AAAA,IAC3D;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmCA,OACI,UACA,SACY;AACZ,WAAO;AAAA,MACH,MAAM;AAAA,MACN;AAAA,MACA,WAAW,SAAS;AAAA,MACpB,aAAa,SAAS;AAAA,IAC1B;AAAA,EACJ;AACJ;AAGO,IAAM,cAAwC;AAAA,EACjD,MAAM;AAAA,EACN,QAAQ,cAAc,OAAO;AAAA,EAC7B,aAAa;AACjB;AAEO,IAAM,cAAwC;AAAA,EACjD,MAAM;AAAA,EACN,QAAQ,cAAc,OAAO;AAAA,EAC7B,aAAa;AACjB;AAEO,IAAM,eAA0C;AAAA,EACnD,MAAM;AAAA,EACN,QAAQ,cAAc,QAAQ;AAAA,EAC9B,aAAa;AACjB;AAQO,IAAM,eAAN,MAAmB;AAAA;AAAA,EAEtB,OAAe,QAAQ,oBAAI,IAA4B;AAAA,EAMvD,OAAO;AACH,SAAK,aAAa,WAAW;AAC7B,SAAK,aAAa,WAAW;AAC7B,SAAK,aAAa,YAAY;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAO,aAA+B,gBAAyC;AAC3E,QAAI,KAAK,MAAM,IAAI,eAAe,IAAI,GAAG;AACrC,YAAM,IAAI,MAAM,SAAS,eAAe,IAAI,yBAAyB;AAAA,IACzE;AACA,SAAK,MAAM,IAAI,eAAe,MAAM,cAAc;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,QAAQ,UAA8C;AACzD,WAAO,KAAK,MAAM,IAAI,QAAQ;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,QAAQ,UAA2B;AACtC,WAAO,KAAK,MAAM,IAAI,QAAQ;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,cAAmD;AACtD,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,OAAO,eAAyB;AAC5B,WAAO,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC;AAAA,EACvC;AACJ;AAmCO,SAAS,WACZ,MACA,QACA,aACiB;AACjB,QAAM,iBAAoC;AAAA,IACtC;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAEA,eAAa,aAAa,cAAc;AACxC,SAAO;AACX;;;AChTO,IAAM,kBAAN,MAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAczB,OAAO,cAAc,OAAgB,QAAkC;AACnE,UAAM,SAAmB,CAAC;AAE1B,YAAQ,OAAO,MAAM;AAAA,MACjB,KAAK;AACD,aAAK,kBAAkB,OAAO,QAA2B,MAAM;AAC/D;AAAA,MACJ,KAAK;AACD,aAAK,cAAc,OAAO,QAAuB,MAAM;AACvD;AAAA,MACJ,KAAK;AACD,aAAK,eAAe,OAAO,QAAwB,MAAM;AACzD;AAAA,MACJ,KAAK;AACD,aAAK,eAAe,OAAO,QAAwB,MAAM;AACzD;AAAA,MACJ;AACI,cAAM,mBAAmB;AACzB,cAAM,IAAI,MAAM,wBAAyB,iBAAyB,IAAI,EAAE;AAAA,IAChF;AAEA,WAAO,EAAE,SAAS,OAAO,WAAW,GAAG,OAAO;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAe,kBAAkB,OAAgB,QAAyB,QAAwB;AAC9F,UAAM,eAAe,OAAO;AAC5B,UAAM,aAAa,OAAO;AAE1B,QAAI,iBAAiB,YAAY,eAAe,YAAY,MAAM,KAAe,GAAG;AAChF,aAAO,KAAK,4BAA4B;AACxC;AAAA,IACJ;AAEA,QAAI,eAAe,cAAc;AAC7B,aAAO,KAAK,YAAY,YAAY,SAAS,UAAU,EAAE;AAAA,IAC7D;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,OAAe,cAAc,OAAgB,QAAqB,QAAwB;AACtF,QAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACvB,aAAO,KAAK,gBAAgB;AAC5B;AAAA,IACJ;AAGA,QAAI,OAAO,aAAa,UAAa,MAAM,SAAS,OAAO,UAAU;AACjE,aAAO,KAAK,4BAA4B,OAAO,QAAQ,eAAe,MAAM,MAAM,EAAE;AAAA,IACxF;AACA,QAAI,OAAO,aAAa,UAAa,MAAM,SAAS,OAAO,UAAU;AACjE,aAAO,KAAK,2BAA2B,OAAO,QAAQ,eAAe,MAAM,MAAM,EAAE;AAAA,IACvF;AAGA,QAAI,OAAO,SAAS,OAAO,MAAM,SAAS,GAAG;AACzC,UAAI,OAAO,MAAM,WAAW,GAAG;AAE3B,cAAM,aAAa,OAAO,MAAM,CAAC;AACjC,cAAM,QAAQ,CAAC,MAAM,UAAU;AAC3B,gBAAM,iBAAiB,KAAK,cAAc,MAAM,UAAU;AAC1D,cAAI,CAAC,eAAe,SAAS;AACzB,kBAAM,aAAa,eAAe,OAAO,IAAI,WAAS,QAAQ,KAAK,MAAM,KAAK,EAAE;AAChF,mBAAO,KAAK,GAAG,UAAU;AAAA,UAC7B;AAAA,QACJ,CAAC;AAAA,MACL,OAAO;AAGH,YAAI,MAAM,WAAW,OAAO,MAAM,QAAQ;AACtC,iBAAO,KAAK,qBAAqB,OAAO,MAAM,MAAM,sBAAsB,MAAM,MAAM,WAAW;AAAA,QACrG;AAKA,eAAO,MAAM,QAAQ,CAAC,YAAY,UAAU;AACxC,cAAI,QAAQ,MAAM,QAAQ;AACtB,kBAAM,iBAAiB,KAAK,cAAc,MAAM,KAAK,GAAG,UAAU;AAClE,gBAAI,CAAC,eAAe,SAAS;AACzB,oBAAM,aAAa,eAAe,OAAO,IAAI,WAAS,iBAAiB,KAAK,KAAK,KAAK,EAAE;AACxF,qBAAO,KAAK,GAAG,UAAU;AAAA,YAC7B;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ,WAAW,OAAO,SAAS,OAAO,MAAM,WAAW,KAAK,MAAM,SAAS,GAAG;AAEtE,aAAO,KAAK,sEAAsE;AAAA,IACtF;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAe,eAAe,OAAgB,QAAsB,QAAwB;AACxF,QAAI,OAAO,UAAU,YAAY,UAAU,QAAQ,MAAM,QAAQ,KAAK,GAAG;AACrE,aAAO,KAAK,iBAAiB;AAC7B;AAAA,IACJ;AAEA,UAAM,MAAM;AAEZ,QAAI,OAAO,UAAU;AACjB,iBAAW,eAAe,OAAO,UAAU;AACvC,YAAI,EAAE,eAAe,MAAM;AACvB,iBAAO,KAAK,+BAA+B,WAAW,GAAG;AAAA,QAC7D;AAAA,MACJ;AAAA,IACJ;AAEA,eAAW,CAAC,KAAK,UAAU,KAAK,OAAO,QAAQ,OAAO,UAAU,GAAG;AAC/D,UAAI,OAAO,KAAK;AACZ,cAAM,iBAAiB,KAAK,cAAc,IAAI,GAAG,GAAG,UAAU;AAC9D,YAAI,CAAC,eAAe,SAAS;AACzB,gBAAM,aAAa,eAAe,OAAO,IAAI,WAAS,aAAa,GAAG,MAAM,KAAK,EAAE;AACnF,iBAAO,KAAK,GAAG,UAAU;AAAA,QAC7B;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI,CAAC,OAAO,sBAAsB;AAC9B,YAAM,cAAc,IAAI,IAAI,OAAO,KAAK,OAAO,UAAU,CAAC;AAC1D,iBAAW,OAAO,OAAO,KAAK,GAAG,GAAG;AAChC,YAAI,CAAC,YAAY,IAAI,GAAG,GAAG;AACvB,iBAAO,KAAK,yBAAyB,GAAG,GAAG;AAAA,QAC/C;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,OAAe,eAAe,OAAgB,QAAsB,QAAwB;AACxF,QAAI,OAAO,aAAa,CAAC,OAAO,UAAU,KAAK,GAAG;AAC9C,aAAO,KAAK,sCAAsC,OAAO,QAAQ,EAAE;AAAA,IACvE;AAEA,QAAI,OAAO,aAAa;AACpB,YAAM,kBAAkB,KAAK,cAAc,OAAO,OAAO,WAAW;AACpE,UAAI,CAAC,gBAAgB,SAAS;AAC1B,eAAO,KAAK,GAAG,gBAAgB,MAAM;AAAA,MACzC;AAAA,IACJ;AAAA,EACJ;AACJ;AAKO,IAAM,oBAAN,MAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAY3B,OAAO,cAAc,gBAAwB,gBAAiC;AAC1E,QAAI,mBAAmB,gBAAgB;AACnC,aAAO;AAAA,IACX;AAEA,UAAM,aAAa,aAAa,QAAQ,cAAc;AACtD,UAAM,aAAa,aAAa,QAAQ,cAAc;AAEtD,QAAI,CAAC,cAAc,CAAC,YAAY;AAC5B,aAAO;AAAA,IACX;AAEA,WAAO,KAAK,qBAAqB,WAAW,QAAQ,WAAW,MAAM;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,OAAO,mBAAmB,gBAAwB,gBAA6C;AAC3F,QAAI,mBAAmB,gBAAgB;AACnC,aAAO,EAAE,cAAc,KAAK;AAAA,IAChC;AAEA,UAAM,aAAa,aAAa,QAAQ,cAAc;AACtD,UAAM,aAAa,aAAa,QAAQ,cAAc;AAEtD,QAAI,CAAC,YAAY;AACb,aAAO;AAAA,QACH,cAAc;AAAA,QACd,QAAQ,wBAAwB,cAAc;AAAA,MAClD;AAAA,IACJ;AAEA,QAAI,CAAC,YAAY;AACb,aAAO;AAAA,QACH,cAAc;AAAA,QACd,QAAQ,wBAAwB,cAAc;AAAA,MAClD;AAAA,IACJ;AAEA,QAAI,CAAC,KAAK,qBAAqB,WAAW,QAAQ,WAAW,MAAM,GAAG;AAClE,aAAO;AAAA,QACH,cAAc;AAAA,QACd,QAAQ,kBAAkB,cAAc,2BAA2B,cAAc;AAAA,MACrF;AAAA,IACJ;AAEA,WAAO,EAAE,cAAc,KAAK;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAcA,OAAO,iBAAiB,MAAiB,gBAA6C;AAClF,WAAO,KAAK,mBAAmB,KAAK,MAAM,cAAc;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe,qBAAqB,cAAsB,cAA+B;AACrF,QAAI,aAAa,SAAS,aAAa,MAAM;AACzC,aAAO;AAAA,IACX;AAEA,YAAQ,aAAa,MAAM;AAAA,MACvB,KAAK;AACD,YAAI,aAAa,SAAS,YAAa,QAAO;AAC9C,eAAQ,aAAiC,SAAU,aAAiC;AAAA,MAExF,KAAK;AACD,YAAI,aAAa,SAAS,QAAS,QAAO;AAC1C,cAAM,oBAAoB;AAC1B,cAAM,oBAAoB;AAE1B,YAAI,CAAC,kBAAkB,SAAS,CAAC,kBAAkB,OAAO;AAEtD,iBAAO,CAAC,kBAAkB,SAAS,CAAC,kBAAkB;AAAA,QAC1D;AACA,YAAI,kBAAkB,MAAM,WAAW,KAAK,kBAAkB,MAAM,WAAW,GAAG;AAC9E,iBAAO,kBAAkB,MAAM,WAAW,kBAAkB,MAAM;AAAA,QACtE;AAGA,YAAI,kBAAkB,MAAM,WAAW,KAAK,kBAAkB,MAAM,WAAW,GAAG;AAC9E,iBAAO,KAAK,qBAAqB,kBAAkB,MAAM,CAAC,GAAG,kBAAkB,MAAM,CAAC,CAAC;AAAA,QAC3F,WAES,kBAAkB,MAAM,WAAW,kBAAkB,MAAM,QAAQ;AACxE,mBAAS,IAAI,GAAG,IAAI,kBAAkB,MAAM,QAAQ,KAAK;AACrD,gBAAI,CAAC,KAAK,qBAAqB,kBAAkB,MAAM,CAAC,GAAG,kBAAkB,MAAM,CAAC,CAAC,GAAG;AACpF,qBAAO;AAAA,YACX;AAAA,UACJ;AACA,iBAAO;AAAA,QACX;AACA,eAAO;AAAA;AAAA,MAEX,KAAK;AACD,YAAI,aAAa,SAAS,SAAU,QAAO;AAC3C,eAAO,KAAK;AAAA,UACR;AAAA,UACA;AAAA,QACJ;AAAA,MAEJ,KAAK;AACD,YAAI,aAAa,SAAS,SAAU,QAAO;AAC3C,eAAQ,aAA8B,aAAc,aAA8B;AAAA,MAEtF;AACI,eAAO;AAAA,IACf;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe,2BAA2B,QAAsB,QAA+B;AAC3F,UAAM,qBAAqB,IAAI,IAAI,OAAO,YAAY,CAAC,CAAC;AACxD,UAAM,aAAa,IAAI,IAAI,OAAO,KAAK,OAAO,UAAU,CAAC;AAEzD,eAAW,eAAe,oBAAoB;AAC1C,UAAI,CAAC,WAAW,IAAI,WAAW,GAAG;AAC9B,eAAO;AAAA,MACX;AAAA,IACJ;AAEA,eAAW,CAAC,KAAK,gBAAgB,KAAK,OAAO,QAAQ,OAAO,UAAU,GAAG;AACrE,UAAI,OAAO,OAAO,YAAY;AAC1B,YAAI,CAAC,KAAK,qBAAqB,OAAO,WAAW,GAAG,GAAG,gBAAgB,GAAG;AACtE,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AACJ;;;AC7WO,IAAM,mBAAN,MAAuB;AAAA,EAC1B,OAAO,gBAAqC,UAAa,OAA2B;AAChF,UAAM,iBAAiB,aAAa,QAAQ,QAAQ;AACpD,QAAI,CAAC,gBAAgB;AACjB,YAAM,IAAI,MAAM,iBAAiB,QAAQ,sBAAsB,aAAa,aAAa,EAAE,KAAK,IAAI,CAAC,EAAE;AAAA,IAC3G;AAEA,UAAM,aAAa,gBAAgB,cAAc,OAAO,eAAe,MAAM;AAC7E,QAAI,CAAC,WAAW,SAAS;AACrB,YAAM,IAAI,MAAM,sCAAsC,QAAQ,MAAM,WAAW,OAAO,KAAK,IAAI,CAAC,EAAE;AAAA,IACtG;AAEA,WAAO,EAAE,MAAM,UAAU,MAAM;AAAA,EACnC;AAAA,EAEA,OAAO,iBAAiB,OAA4C;AAChE,WAAO,KAAK,gBAAgB,UAAU,KAAK;AAAA,EAC/C;AAAA,EAEA,OAAO,iBAAiB,OAA4C;AAChE,WAAO,KAAK,gBAAgB,UAAU,KAAK;AAAA,EAC/C;AAAA,EAEA,OAAO,kBAAkB,OAA+C;AACpE,WAAO,KAAK,gBAAgB,WAAW,KAAK;AAAA,EAChD;AAAA,EAEA,OAAO,cACH,UACA,OAC4E;AAC5E,QAAI;AACA,YAAM,OAAO,KAAK,gBAAgB,UAAU,KAAK;AACjD,aAAO,EAAE,SAAS,MAAM,KAAK;AAAA,IACjC,SAAS,OAAO;AACZ,aAAO;AAAA,QACH,SAAS;AAAA,QACT,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAChE;AAAA,IACJ;AAAA,EACJ;AACJ;AAGO,SAAS,kBAAkB,UAAkB,OAA0B;AAC1E,QAAM,iBAAiB,aAAa,QAAQ,QAAQ;AACpD,MAAI,CAAC,gBAAgB;AACjB,WAAO,CAAC,iBAAiB,QAAQ,EAAE;AAAA,EACvC;AAEA,QAAM,aAAa,gBAAgB,cAAc,OAAO,eAAe,MAAM;AAC7E,SAAO,WAAW;AACtB;AAEO,SAAS,YAAY,UAAwB;AAChD,QAAM,iBAAiB,aAAa,QAAQ,QAAQ;AACpD,MAAI,CAAC,gBAAgB;AACjB,YAAQ,IAAI,SAAS,QAAQ,aAAa;AAC1C;AAAA,EACJ;AAEA,UAAQ,IAAI,aAAa,QAAQ,MAAM;AACvC,UAAQ,IAAI,gBAAgB,eAAe,eAAe,gBAAgB,EAAE;AAC5E,UAAQ,IAAI,WAAW,KAAK,UAAU,eAAe,QAAQ,MAAM,CAAC,CAAC;AACzE;AAEO,SAAS,eAAqB;AACjC,QAAM,WAAW,aAAa,YAAY;AAE1C,UAAQ,IAAI,0BAA0B;AACtC,aAAW,CAAC,MAAM,UAAU,KAAK,UAAU;AACvC,YAAQ,IAAI,GAAG,IAAI,KAAK,WAAW,eAAe,gBAAgB,EAAE;AAAA,EACxE;AACJ;",
  "names": []
}
