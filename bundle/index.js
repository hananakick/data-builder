"use strict";(()=>{var u={string(){return{kind:"primitive",type:"string"}},number(){return{kind:"primitive",type:"number"}},boolean(){return{kind:"primitive",type:"boolean"}},array(s,e){return{kind:"array",items:s,...e}},object(s,e){return{kind:"object",properties:s,required:e?.required,additionalProperties:e?.additionalProperties??!1}},custom(s,e){return{kind:"custom",typeName:s,validator:e?.validator,innerSchema:e?.innerSchema}}},h={name:"string",schema:u.string(),description:"Text string value"},y={name:"number",schema:u.number(),description:"Numeric value"},g={name:"boolean",schema:u.boolean(),description:"True or false value"},a=class{static{this.types=new Map}static{this.registerType(h),this.registerType(y),this.registerType(g)}static registerType(e){if(this.types.has(e.name))throw new Error(`Type '${e.name}' is already registered`);this.types.set(e.name,e)}static getType(e){return this.types.get(e)}static hasType(e){return this.types.has(e)}static getAllTypes(){return this.types}static getTypeNames(){return Array.from(this.types.keys())}};function b(s,e,t){let i={name:s,schema:e,description:t};return a.registerType(i),i}var m=class{static validateValue(e,t){let i=[];switch(t.kind){case"primitive":this.validatePrimitive(e,t,i);break;case"array":this.validateArray(e,t,i);break;case"object":this.validateObject(e,t,i);break;case"custom":this.validateCustom(e,t,i);break;default:let r=t;throw new Error(`Unknown schema kind: ${r.kind}`)}return{isValid:i.length===0,errors:i}}static validatePrimitive(e,t,i){let r=t.type,n=typeof e;if(r==="number"&&n==="number"&&isNaN(e)){i.push("Number value cannot be NaN");return}n!==r&&i.push(`Expected ${r}, got ${n}`)}static validateArray(e,t,i){if(!Array.isArray(e)){i.push("Expected array");return}if(t.minItems!==void 0&&e.length<t.minItems&&i.push(`Array must have at least ${t.minItems} items, got ${e.length}`),t.maxItems!==void 0&&e.length>t.maxItems&&i.push(`Array must have at most ${t.maxItems} items, got ${e.length}`),t.items&&t.items.length>0)if(t.items.length===1){let r=t.items[0];e.forEach((n,o)=>{let c=this.validateValue(n,r);if(!c.isValid){let p=c.errors.map(l=>`Item[${o}]: ${l}`);i.push(...p)}})}else e.length!==t.items.length&&i.push(`Expected tuple of ${t.items.length} elements, but got ${e.length} elements`),t.items.forEach((r,n)=>{if(n<e.length){let o=this.validateValue(e[n],r);if(!o.isValid){let c=o.errors.map(p=>`Item at index ${n}: ${p}`);i.push(...c)}}});else t.items&&t.items.length===0&&e.length>0&&i.push("Array schema defines an empty tuple, but received a non-empty array.")}static validateObject(e,t,i){if(typeof e!="object"||e===null||Array.isArray(e)){i.push("Expected object");return}let r=e;if(t.required)for(let n of t.required)n in r||i.push(`Missing required property: '${n}'`);for(let[n,o]of Object.entries(t.properties))if(n in r){let c=this.validateValue(r[n],o);if(!c.isValid){let p=c.errors.map(l=>`Property '${n}': ${l}`);i.push(...p)}}if(!t.additionalProperties){let n=new Set(Object.keys(t.properties));for(let o of Object.keys(r))n.has(o)||i.push(`Unexpected property: '${o}'`)}}static validateCustom(e,t,i){if(t.validator&&!t.validator(e)&&i.push(`Custom validation failed for type: ${t.typeName}`),t.innerSchema){let r=this.validateValue(e,t.innerSchema);r.isValid||i.push(...r.errors)}}},d=class{static areCompatible(e,t){if(e===t)return!0;let i=a.getType(e),r=a.getType(t);return!i||!r?!1:this.areSchemasCompatible(i.schema,r.schema)}static checkCompatibility(e,t){if(e===t)return{isCompatible:!0};let i=a.getType(e),r=a.getType(t);return i?r?this.areSchemasCompatible(i.schema,r.schema)?{isCompatible:!0}:{isCompatible:!1,reason:`Type mismatch: ${e} is not compatible with ${t}`}:{isCompatible:!1,reason:`Unknown target type: ${t}`}:{isCompatible:!1,reason:`Unknown source type: ${e}`}}static isNodeCompatible(e,t){return this.checkCompatibility(e.type,t)}static areSchemasCompatible(e,t){if(e.kind!==t.kind)return!1;switch(e.kind){case"primitive":return t.kind!=="primitive"?!1:e.type===t.type;case"array":if(t.kind!=="array")return!1;let i=e,r=t;if(!i.items||!r.items)return!i.items&&!r.items;if(i.items.length===0||r.items.length===0)return i.items.length===r.items.length;if(i.items.length===1&&r.items.length===1)return this.areSchemasCompatible(i.items[0],r.items[0]);if(i.items.length===r.items.length){for(let n=0;n<i.items.length;n++)if(!this.areSchemasCompatible(i.items[n],r.items[n]))return!1;return!0}return!1;case"object":return t.kind!=="object"?!1:this.areObjectSchemasCompatible(e,t);case"custom":return t.kind!=="custom"?!1:e.typeName===t.typeName;default:return!1}}static areObjectSchemasCompatible(e,t){let i=new Set(t.required||[]),r=new Set(Object.keys(e.properties));for(let n of i)if(!r.has(n))return!1;for(let[n,o]of Object.entries(t.properties))if(n in e.properties&&!this.areSchemasCompatible(e.properties[n],o))return!1;return!0}};var f=class{static createTypedNode(e,t){let i=a.getType(e);if(!i)throw new Error(`Unknown type: ${e}. Available types: ${a.getTypeNames().join(", ")}`);let r=m.validateValue(t,i.schema);if(!r.isValid)throw new Error(`Schema validation failed for type '${e}': ${r.errors.join("; ")}`);return{type:e,value:t}}static createStringNode(e){return this.createTypedNode("string",e)}static createNumberNode(e){return this.createTypedNode("number",e)}static createBooleanNode(e){return this.createTypedNode("boolean",e)}static tryCreateNode(e,t){try{return{success:!0,node:this.createTypedNode(e,t)}}catch(i){return{success:!1,error:i instanceof Error?i.message:String(i)}}}};function x(s,e){let t=a.getType(s);return t?m.validateValue(e,t.schema).errors:[`Unknown type: ${s}`]}function C(s){let e=a.getType(s);if(!e){console.log(`Type '${s}' not found`);return}console.log(`=== Type: ${s} ===`),console.log(`Description: ${e.description||"No description"}`),console.log("Schema:",JSON.stringify(e.schema,null,2))}function j(){let s=a.getAllTypes();console.log("=== Registered Types ===");for(let[e,t]of s)console.log(`${e}: ${t.description||"No description"}`)}})();
